
Autori [X] rozšířili popsaný algoritmus tak aby se výpočet del efektivně distribuovat. Hodnoty jednotlivých hodnocení stem:[r_{ui}] byly nahrazeny odvozenou binární proměnnou stem:[p_{ui}] tak, že platí:

[stem]
++++
\begin{align*}
 \begin{equation}
 p_{ui}=
  \begin{cases}
   0 & r_{ui}=0 \\
   1 & r_{ui}>0
  \end{cases}
 \end{equation}
\end{align*}
++++

Tedy pokud uzivatel dosud polozku 'nezkonzumoval' promenna nabývá hodnotu v opečném připadě hodnotu stem:[1]. Důvěra v tuto hodnotu je vysoce proměnlivá. Jak již bylo řečeno pro nulové hodnoty to může znamenat, že uživatel o položce zatím neví. Pro souPlatí tedy:

[stem]
++++
p_{ui}=x_{u}^Ty_{i}  
++++

Dále pokud čim je počet konzumací vyšsí tím více narůstá důvěra v hodnotu stem:[p_{ui}=1]. Autoři článku vyjádřili důvěru v hodnotu stem:[p_{ui}] následovně:

[stem]
++++
c_{ui} = 1 + \alpha r_{ui}
++++

Existuje tedy minimální důvěra stem:[1] pro zatim nezkonzumované položky. Hodnota proměnné lineárně narůstá s počtem užití produktu. Poměr nárustu je dán konstantou stem:[\alpha], přesná hodnota tohoto paramteru je specifická pro konkrétní dataset a bude odvozena v rámci experimentální fáze. Pro kazdeho uživatele máme k dispozici stem:[i] hodnotu stem:[c], jednu pro kazdou polozku. Tyto hodnoty prevedeme do diagonální matice stem:[C_{u}] s rozmery stem:[ixi]. V rovnici bude tato matice figurovat jako váhy. Tedy:

[stem]
++++
 C_{u}Yx_{u} = C_{u}p_{u}
++++

Rovnici násobíme transpozicí položkové faktorové matice. Tímot rovnici převedem do normální vážené formy. 

[stem]
++++
 Y^TC_{u}Yx_{u} = Y^TC_{u}p_{u}
++++  

Osamostatníme vektor faktoru uživatele a přidáme regulariza%cní parametr viz <<REGULACE>>. Výsledna rovnice, která vyjadřuje výpočet faktoru pro jediného uyivatele odpovida

[stem]
++++
 x_{u} = (Y^TC_{u}Y + \lambda I)^{-1}Y^TC_{u}p_{u}
++++    
     
Problem pri vypoctu je vyraz stem:[Y^TC_{u}Y]. Zde by se muselo opakovane provadet pro kazdeho uzivatele nasobeni produktove fakrotove matice a diagonalni matice s preferencemi daneho uzivatele. Fakrotove matice je v rámci distribuovaného vzpočtu typicky rozdělena na více vypočetních uzlů a jeji nasobenio vyzaduje vymeny bloku dat v ramci celeho vypocetniho clusteru. Autori clanku vyresili tento problem elegantne. Vyraz stem:[Y^TC_{u}Y] prevedli na vyraz: 

[stem]
++++
Y^TY+Y^T(C_{u}-I)Y 
++++
  
Zde nejprev predpocitame stem:[Y^TY] a nasledne pricitame pro kazdeho uzivatele stem:[Y^T(C_{u}-I)Y]. Zde nam z vypoctu vypadnou vsechny produkty, ktere nemaji pro daneho uzivatele zadne hodnoceni - tyot maji v diagonalni matici stem:[C_{u}] hodnotu stem:[1] (stem:[c_{ui} = 1 + \alpha r_{ui}]) a odectenim jednotkove matice ziskame matici kde jsou v prislusnych radcich same nuly. Stejne pripad je i vyraz stem:[Y^TC_{u}p_{u}], kde take neresime chybejici hodnoceni pro ktere obsahuje vektor pu nulove hodnoty. V ramci distrubovaneho vypoctu muzeme drzet pri vypoctu hodnoceni a faktorove matice na jednom vypocetnim uzlu a provadet vypocty lokalne.    
    
   
konzumace = užití

