
=== Alternating Least Square (ALS)

Hyper paramtery maji vliv na vysledne hodnoty, jejich optimalni hodnoty jsou zavisle na datasetu, pro ktery vyvarime model. Presne hodnoty odvodime pri experimentovani pomoci krizove validace. NAs Algoritmus bude podporovat nasledujici vstupni hyper parametry:

rank::
    Rank urcuje dimenzi faktorovych vektoru. Tato dimenze je stejna jak pro uzivatele tak i pro polozky. Pokud je velikost faktorovych veektoru prilis nizka, model bude prilis zjednduseny a nebude podavat optimalni vykon. Na druhou stranu pokud bude jejich velikost prilis velka, muze dojit k takzvanemu preuceni kdy model bude prilis spjaty s trenovacimi daty. Vyhozi hodnota je 10.
    
alpha::
    Alpha nastavuje pomer narustu duvery v hodnoceni, viz <<ALS>>. Vychozi hodnota je 0.1.
    
regParam::
    Regularizacni parametr zabranuje preuceni modelu, viz <<REGULARIZATION>>. Hodnota 0 ma za nasledek, ze se pri vypoctu regulaizace neaplikuje. Vychopzi hodnota je 0.1.  
    
Trenovaci parametry nemaji primo vliv na nastaveni vypoctu ale muzeme pomoci nich kontrolovat jak budou data distribuovana v ramci vypocetniho klusteru. Data jsou pred vypoctem samotnym rozdeleny do bloku. Tyto bloky jsou vlastne partition a jsou nasledne zpracovavany parallelne. Zvoleny pocet bloku ma zasadni dopad na to, jak dlouho zabere vytvoreni modelu. Dle <<HDG>> je optimalni velikost bloku mezi jednim az peti miliony hodnoceni. Nas algoritmus bude podporovat nasledujici trenovaci parametry:

numUserBlocks::
    POcet bloku do kterych budou rozdeleleni uzivatele, vychozi hodnota je 10. 

numItemBlocks::
    POcet bloku do kterych budou rozdelelene polozky, vychozi hodnota je 10.
    
maxIter::
    POcet iteraci pri vypoctu. V kazde iteraci se provede vypocet uzivatelskych a polozkovych faktoru. Po danem poctu iteraci se jiz vysledne faktory nemeni a nema smysl ve vypoctu pokracovat. Presny pocet zjistime napriklad pomoci RMSE. Vychozi hodnota je 10.     

Hodnoceni nejprve rozdelime do jednotlivych bloku.  

Pro praci s bloky zvolime rozdilnou terminologii nez rozdelenmi na uzivatele a polozky. Vzhledem k povaze algoritmu, kdy se stridave porvadi vypocet faktoru zvlast pro uzvatele a zvlast pro polozky, pouzijeme pro oba stejny algoritmus a vytvorime pro ne analogicke struktury. Jednou budou jako cil vypoctu uzivatelske faktory, ktere pouziji jako zdroj pro vypocet faktory polkozkove. Podruhe to bude naopak. Dale tedy budeme pro vysvetleni algoritmu pouzivat terminy zdroj a cil. 

Pro vyhodnoceni ciloveho bloku vytvorime jednoduchou hashovaci funkci. Tato rozdeli hodnoceni rovnomerne dle zvoleneho celkove poctu bloku. Kazdemu uzivateli resp polozce prideli cilovy blok na zaklade jejich celociselneho identifikatoru. Vysleden cislo bloku bude take cele cislo v rade zacinajici nulou. Id bloku tedy take zaroven jeho indexem v sade prislusnych bloku. 

[[als_block_diagram]]
image::als_block_diagram02022020.jpg[title="Diagram bloku hodnoceni", pdfwidth="75%"]


V diagramu je <<als_block_diagram>> je ukazana struktura bloku. Pro kazdy blok hodnceni vzniknou tri nezavisle struktury:

Blok::
    Zakladni struktura, obsahujici prislusna hodnoceni. Tyto bloky se inicializuji na zacatku vypoctu na zaklade vstupnich dat. Data v nich zustavaji konstantni pres vsechny iterace vypoctu. Vypocet se provadi lokalne na uzlu kde jsou tyto data ulozena, neni tedy potreba tyto bloky v prubehu vypoctu prenaset po siti v ramci vypocetniho clustru. V techto blocich je jeden z identifikatoru zvolen jak zdrojovy a druhy jako cilovy. Hodnoceni jsou nasledne serazena dle zdrojoveho identifikatoru (vzestupne). Data v bloku zkomprimuje do takzvane CSC (compressed sparse column) struktury. Vzheledem k tomu, ze jeden zdrojovy identifikator muze byt v datech zastoupeny nekolikrat, vybereme nejprve unikatni zdrojove identifikatory viz (Zdrojove ID) <<als_block_diagram>>. K temto identifikatorum priradime ukazatel do bloku hodnoceni. Tento ukazatel urcuje ke kterym hodnocenim prislusne zdrojove ID patri. Cilovy identifikator nahradime v datech identifikatorem ciloveho bloku a tazkvanym lokalnim indexem. Localni index urcuje index serazenych unikatnich cilovych id pro dany zdrojovy a cilovy blok. Tyto idenitifikatory provazuji zdrojovy blok a cilovy meta blok.
    
Blok faktoru::
    Pro kazde unikatni zdrojove id v ramci propojeneho bloku bude v tomto bloku prave jeden faktorovy vektor. Dimenze techto vektoru je dana zvolenym rankem, typicky se jedna o relativne male cislo, viz vychozi hodnota 10. Tyto faktory se prepocitaji v ramci kazde iterace a jsou nasledne pouzity jako zdroj pro vypocet cilovych faktoru. Tyto bloky bude tedy nutne v prubehu distribuovaty jako zdroj. Blok faktoru inicializujeme na zacatku vypoctu a jednotlivym faktorum priradime nahodne hodnoty.
    
Meta blok::
    Na zaklade dat v bloku vytvorime takzvany metablok. Metabloky provazuji mezi sebou zdrojove a cilove bloky. Realne se jedna o dvourozmerne pole kde je zaznam pro kazdy cilovy blok. V techto zaznamech jsou zdrojova id, pro ktere existuje  hodnoceni v danem zdrojovem a cilovem bloku. 
       
[[als_block_connection]]
image::als_block_connection02022020.jpg[title="Diagram propojeni bloku", pdfwidth="75%"]


Na obrazku <<als_block_connection>> je zobrazene propojeni mezi zdrojovymi a cilovymi bloky. POkud chceme spocitat zdrojovy faktor pro jedno zdrojove id (30)musime do linearniho systemu zahrnou vsechny cilove faktory (cilove id 5, 12) pro ktere existuje hodnoceni pro dane zdrojove a cilove id. Tyto mohou byt typicky v rozdilnych cilovych blocich (1, 4) ulozenych na rozdilnych uzlech v ramci clustru.


Jako top level vstup do algoritmu pouzijeme strukturovane API jako preferrovany zpusob od druhe generace Sparku:



Pro praci s hodnocenimi pouzijeme RDD Api. Toto api nizsi urovne nam, narozdil od doporucovaneho strukturovaneho API, dava moznost ridit rozlozeni dat v ramci clusteru. Jako vstup do casti algoritmu, ktery nam rozdeli hodnoceni do prislusnych bloku bude dataset usporadanych trojic. Tato trojice se sklada ze sdrojoveh id (srcId), ciloveho id (dstId) a hodnoceni. Zshledem k to mu ze budeme vytvaret analogicke blokove struktury pro uzivatele i polozky  

[source, scala, numbered]
----
include::{scala-dir}/mlonspark/ALSEngine.scala[tags=params-def]
----


Cilovy blok urcime na zaklade identifikatoru uzivatele resp. identifikatoru polozky dle zbytku po celosielnem delenim pozadovanym poctem bloku. Toto nam zajisti, ze kazde unikatni identifikator se vzdy priradi prave do jednoho konkretniho bloku. Vzhledem k tomu ze vypocet probiha stridave pro vypocet uzivatelskych i produktovych faktoru, pouzijeme pro oba stejny algoritmus a vytvorime pro ne analogicke struktury. Pri vypoctu uzivatelskych faktoru poslouzi polozkove bloky jako zdroj a naopak.      

